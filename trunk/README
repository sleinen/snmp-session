		       SNMP support for Perl 5
		       -----------------------

	       Author: Simon Leinen  <simon@switch.ch>
			    Contributors:
		 Tobias Oetiker  <oetiker@ee.ethz.ch>
		 Andrzej Tobola  <san@iem.pw.edu.pl>
		      Dave Rand  <dlr@Bungi.com>
		    Heine Peters  <peters@dkrz.de>
		      Yufang HU  <yhu@casc.com>
	       Philippe Simonet  <sip00@vg.swissptt.ch>

This archive contains Perl 5 modules SNMP_Session.pm and BER.pm,
which, when used together, provide rudimentary access to remote SNMP
(v1) agents.

This module differs from existing SNMP packages in that it is
completely stand-alone, i.e. you don't need to have another SNMP
package such as CMU SNMP.  It is also written entirely in Perl, so you
don't have to compile any C modules.  It uses the Perl 5 Socket.pm
module and should therefore be very portable, even to non-Unix systems.

The SNMP operations currently supported are "get" and "get-next".
That means that you can neither set variables in an agent, nor receive
or generate SNMP traps using these routines.  Hopefully I will get
around to implementing these other operations one day.

For an excellent example of the type of application this is useful
for, see Tobias Oetiker's ``mrtg'' (Multi Router Traffic Grapher)
tool: <URL:http://www.ee.ethz.ch/~oetiker/webtools/mrtg/mrtg.html>

				Usage
				.....

The basic usage of these routines works like this:

	use BER;
	require 'SNMP_Session.pm';

	# Set $host to the name of the host whose SNMP agent you want
	# to talk to.  Set $community to the community name under
	# which you want to talk to the agent.	Set port to the UDP
	# port on which the agent listens (usually 161).

	$session = SNMP_Session->open ($host, $community, $port);

	# Set $oid1, $oid2... to the BER-encoded OIDs of the MIB
	# variables you want to get.

	if ($session->get_request_response ($oid1, $oid2, ...)) {
	    ($bindings) = $session->decode_get_response ($session->{pdu_buffer});
	
	    while ($bindings ne '') {
		($binding,$bindings) = &decode_sequence ($bindings);
		($oid,$value) = &decode_by_template ($binding, "%O%@");
		print $pretty_oids{$oid}," => ",
		      &pretty_print ($value), "\n";
	    }
	} else {
	    die "No response from agent on $host";
	}

			    Encoding OIDs
			    .............

In order to BER-encode OIDs, you can use the function BER::encode_oid.
It takes (a vector of) numeric subids as an argument.  For example,

	use BER;
	encode_oid (1, 3, 6, 1, 2, 1, 1, 1, 0)

will return the BER-encoded OID for the sysDescr.0 (1.3.6.1.2.1.1.1.0)
instance of MIB-2.

			 Decoding the results
			 ....................

When get_request_response returns success, you must decode the
response PDU from the remote agent.  The function
`decode_get_response' can be used to do this.  It takes a get-response
PDU, checks its syntax and returns the "bindings" part of the PDU.
This is where the remote agent actually returns the values of the
variables in your query.

You should iterate over the individual bindings in this "bindings"
part and extract the value for each variable.  In the example above,
the returned bindings are simply printed using the BER::pretty_print
function.  The hash %pretty_oids in the example contains a mapping
from BER-encoded OIDs to "readable" instance names.  Look at the
source of the real example programs to see how this is constructed.

			     Future Plans
			     ............

			    SNMPv2 Support

The SNMP_Session type has already been subclassed into SNMPv1_Session
and SNMPv2_Session.  There is also some code to parse party database
from the CMU SNMPv2 package.  The same should be done for the context
database.  Then I can to write a method that creates a SNMPv2_Session
from source and destination parties and a context, and write PDU
encoding/decoding methods that handle the SNMPv2 packet formats.  MD5
hashing and DES encryption should be added so that authentication and
privacy can be used.  Then the getBulk PDU should be implemented.

Unfortunately(?) this is all more or less moot since the
``traditional'' SNMPv2 party model has been abandoned because it was
considered to be too difficult to deploy.  The current standard is
SNMPv2C, which is basically SNMPv2 with the community-based
``security'' model from SNMPv1.  This would still be worthwhile
because of the addition of getBulk and other improvements.  However, I
don't have any agent implementation I could test my code against.

			   More Operations

Adding the set operation should not be very difficult.  Support for
receiving and/or sending traps would be useful for some management
applications.

			     MIB parsing

Currently, users of the module must provide numeric object IDs, and
should know the types of the variables they request.  It would be nice
if we could read MIBs in some form, and provide the possibility to use
symbolic variable names and do automatic decoding according to the
variable types specified in the MIB.

However, parsing MIBs in their full ASN.1 syntax looks like overkill
for such a small package.  As a compromise, we could use the output of
an existing MIB compiler as input.  I have done this in another
project (see http://www.switch.ch/misc/leinen/snmp/lisp/) with files
from ISODE SNMP's MIB compiler.  A problem with ISODE SNMP is that it
is itself part of a rather huge package, and I would prefer to use a
small standalone MIB parser.  Ideally this MIB parser would handle all
kinds of MIBs, also SNMPv2 ones, and be able to generate easily
readable files with the information we need (name-to-oid and
name-to-type or oid-to-type mappings).

			  Higher-Level APIs

The current programming interface is very close to the level of SNMP
operations and PDUs.  For actual management applications, there are
probably more convenient interfaces that could be defined.

At the very least, there should be an interface to traverse tables,
but of course this will only become relevant once the getNext is
implemented.  The implementation of the table-traversing interface
should use getBulk on SNMPv2 sessions.
