<HTML>
 <HEAD>
  <TITLE>SNMP support for Perl 5</TITLE>
 </HEAD>
 <BODY>
<CENTER>
  <H1>SNMP support for Perl 5</H1>

  <H3>Author: <A HREF="http://www.switch.ch/misc/leinen/">Simon
Leinen</A>  &lt;<A HREF="mailto:simon@switch.ch">simon@switch.ch</A>&gt;</H3>

</CENTER>

<P> <A
 HREF="http://www.switch.ch/misc/leinen/snmp/perl/snmp.tar.gz">This
 archive</A> contains Perl 5 modules <tt>SNMP_Session.pm</tt> and
 <tt>BER.pm</tt>, which, when used together, provide rudimentary
 access to remote SNMP (v1) agents. </P>

<H2>Features</H2>

<P> This module differs from existing SNMP packages in that it is
 completely stand-alone, i.e. you don't need to have another SNMP
 package such as CMU SNMP.  It is also written entirely in Perl, so
 you don't have to compile any C modules.  It uses the Perl 5
 <SAMP>Socket.pm</SAMP> module and should therefore be very
 portable, even to non-Unix systems. </P>

<p> The SNMP operations currently supported are "get" and
 "get-next". That means that you can neither set variables in an
 agent, nor receive or generate SNMP traps using these routines.
 Hopefully I will get around to implementing these other operations
 one day. </p>

<p> For an excellent example of the type of application this is useful
 for, see Tobias Oetiker's <a
 href="http://www.ee.ethz.ch/~oetiker/webtools/mrtg/mrtg.html">``mrtg''
 (Multi Router Traffic Grapher)</a> tool </p>

<!-- <P> You can try a trivial <A				-->
<!-- HREF="http://liawww.epfl.ch/cgi-bin/snmp/wwwtest">sample	-->
<!-- application</A> I have built with this library. </P>	-->

<h2> Recent Changes: </h2>

<ul>

<li> The code has been cleaned up to use more of the standard
 functionality of the Perl 5 <tt>Socket.pm</tt> module.  That should
 have eliminated some potential portability problems (and delegated
 responsability for potential bugs :-). </li>

<li> The library now attempts to retransmit queries for which no
 reponse has been received during a given time.  The default
 parameters for the retransmission logic have been discussed at length
 in the <em>mrtg</em> mailing list, and seem to work quite well, both
 against overloaded routers that simply drop some SNMP requests and
 against routers that are behind slow or lossy links.  If you have
 feedback on the default parameters, please drop me an e-mail. </li>

<li> When I implemented the retransmission logic, I also fixed
 handling of request IDs.  In older versions, the request ID was never
 changed between reqeuest, which could lead to (late) resposes being
 associated with the wrong request.  Now the request ID is incremented
 for each request, and mismatching responses are ignored.  For
 retransmissions, the request ID isn't changed.  If we did change it,
 we could estimate response time and implement an adaptive
 retransmission algorithm.  This has been left for further
 study. </li>

<li> Added code contributed by <em>mrtg</em> users:

 <ul>

  <li> Encoding of larger subids, by <a
 href="mailto:sip00@vg.swissptt.ch">Philippe Simonet</a> and <a
 href="mailto:yhu@casc.com">Yufang HU</a> </li>

  <li> Decoding <tt>sysUpTime</tt>, by <a
 href="mailto:dlr@Bungi.com">Dave Rand</a> </li>

  <li> Decoding longer (unsigned) integers, by <a
 href="mailto:oetiker@ee.ethz.ch">Tobias Oetiker</a> </li>

  <li> Decoding longer strings, by <a
 href="mailto:san@iem.pw.edu.pl">Andrzej Tobola</a> </li>

  <li> More reasonable socket initialization, by <a
 href="mailto:peters@dkrz.de">Heine Peters</a> </li>

 </ul> </li>

</ul>

<H2>Usage</H2>

<P> The basic usage of these routines works like this: </P>

<PRE>
use BER;
require 'SNMP_Session.pm';

# Set $host to the name of the host whose SNMP agent you want
# to talk to.  Set $community to the community name under
# which you want to talk to the agent.	Set port to the UDP
# port on which the agent listens (usually 161).

$session = SNMP_Session->open ($host, $community, $port);

# Set $oid1, $oid2... to the BER-encoded OIDs of the MIB
# variables you want to get.

if ($session-&gt;get_request_response ($oid1, $oid2, ...)) {
    ($bindings) = $session-&gt;decode_get_response ($session-&gt;{pdu_buffer});

    while ($bindings ne '') {
	($binding,$bindings) = &amp;decode_sequence ($bindings);
	($oid,$value) = &amp;decode_by_template ($binding, "%O%@");
	print $pretty_oids{$oid}," =&gt; ",
	      &amp;pretty_print ($value), "\n";
    }
} else {
    die "No response from agent on $host";
}
</PRE>

<H2>Encoding OIDs</H2>

<P> In order to BER-encode OIDs, you can use the function
<B>BER::encode_oid</B>.  It takes (a vector of) numeric subids as an
argument.  For example, </P>

<PRE>
use BER;
encode_oid (1, 3, 6, 1, 2, 1, 1, 1, 0)
</PRE>

<P> will return the BER-encoded OID for the <B>sysDescr.0</B>
 (1.3.6.1.2.1.1.1.0) instance of <A
 HREF="http://ds.internic.net/rfc/rfc1213.txt">MIB-2</A>. </P>

<H2>Decoding the results</H2>

<P> When get_request_response returns success, you must decode the
 response PDU from the remote agent.  The function
 <B>decode_get_response</B> can be used to do this.  It takes a
 get-response PDU, checks its syntax and returns the <EM>bindings</EM>
 part of the PDU.  This is where the remote agent actually returns the
 values of the variables in your query. </P>

<P> You should iterate over the individual bindings in this
 <EM>bindings</EM> part and extract the value for each variable.  In
 the example above, the returned bindings are simply printed using the
 <B>BER::pretty_print</B> function.  The hash <B>%pretty_oids</B> in
 the example contains a mapping from BER-encoded OIDs to "readable"
 instance names.  Look at the source of the real example programs to
 see how this is constructed. </P>

<H2>Future Plans</H2>

<H3>SNMPv2 Support</H3>

<P> The <B>SNMP_Session</B> type has already been subclassed into
 <B>SNMPv1_Session</B> and <B>SNMPv2_Session</B>.  There is also some
 code to parse party database from the CMU SNMPv2 package.  The same
 should be done for the context database.  Then I can to write a
 method that creates a <B>SNMPv2_Session</B> from source and
 destination parties and a context, and write PDU encoding/decoding
 methods that handle the SNMPv2 packet formats.  MD5 hashing and DES
 encryption should be added so that authentication and privacy can be
 used.  Then the <SAMP>getBulk</SAMP> PDU should be implemented. </P>

<p> Unfortunately(?) this is all more or less moot since the
 ``traditional'' SNMPv2 party model has been abandoned because it was
 considered to be too difficult to deploy.  The current standard is
 SNMPv2C, which is basically SNMPv2 with the community-based
 ``security'' model from SNMPv1.  This would still be worthwhile
 because of the addition of <SAMP>getBulk</SAMP> and other
 improvements.  However, I don't have any agent implementation I could
 test my code against. </p>

<H3>More Operations</H3>

<p> Adding the <SAMP>set</SAMP> operation should not be very
 difficult.  Support for receiving and/or sending traps would be
 useful for some management applications. </p>

<H3>MIB parsing</H3>

<P> Currently, users of the module must provide numeric object IDs,
 and should know the types of the variables they request.  It would be
 nice if we could read MIBs in some form, and provide the possibility
 to use symbolic variable names and do automatic decoding according to
 the variable types specified in the MIB. </P>

<P> However, parsing MIBs in their full ASN.1 syntax looks like
 overkill for such a small package.  As a compromise, we could use the
 output of an existing MIB compiler as input.  I have done this in <A
 HREF="http://www.switch.ch/misc/leinen/snmp/lisp/">another project</A>
 with files from ISODE SNMP's MIB compiler.  A problem with ISODE SNMP
 is that it is itself part of a rather huge package, and I would
 prefer to use a small standalone MIB parser.  Ideally this MIB parser
 would handle all kinds of MIBs, also SNMPv2 ones, and be able to
 generate easily readable files with the information we need
 (name-to-oid and name-to-type or oid-to-type mappings). </P>

<H3>Higher-Level APIs</H3>

<P> The current programming interface is very close to the level of
 SNMP operations and PDUs.  For actual management applications, there
 are probably more convenient interfaces that could be defined. </P>

<P> At the very least, there should be an interface to traverse
 tables, but of course this will only become relevant once the
 <SAMP>getNext</SAMP> is implemented.  The implementation of the
 table-traversing interface should use <SAMP>getBulk</SAMP> on SNMPv2
 sessions. </P>

<HR>
<ADDRESS>
<!-- hhmts start -->
Last modified: Mon Apr 28 20:46:20 MET DST 1997
<!-- hhmts end -->
<A HREF="http://www.switch.ch/misc/leinen/">
 Simon Leinen &lt;simon.leinen@switch.ch&gt;</A>
</ADDRESS>

</BODY>
</HTML>
