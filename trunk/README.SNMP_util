
		       README for SNMP_util.pm

		   Mike Mitchell <mcm@unx.sas.com>

I was using Simon Leinen's SNMP tools in various perl scripts, and I
found that I was using the same functions over and over.  I grouped
the common routines into a separate perl module so that I would only
have to make changes in one place, rather than track down all the
different perl scripts that included the code.  The result is the
'SNMP_utils.pm' module.

Thanks goes to Tobias Oetiker (oetiker@ee.ethz.ch) of MRTG fame
for the basic layout of the functions.

The SNMP_utils.pm module contains the functions

  snmpmapOID(text, OID, [text, OID ...])
  snmpMIB_to_OID(filename)
  snmpLoad_OID_Cache(filename)
  snmpQueue_MIB_File(filename, [filename])

  snmpget(community@host:port:timeout:retries:backoff, OID, [OID...])
  snmpgetnext(community@host:port:timeout:retries:backoff, OID, [OID...])
  snmpwalk(community@host:port:timeout:retries:backoff, OID)
  snmpset(community@host:port:timeout:retries:backoff, OID, type, value,
	    [OID, type, value ...])
  snmptrap(community@host:port:timeout:retries:backoff, enterpriseOID,
	    agent, generalID, specificID, OID, type, value,
	    [OID, type, value ...])


The functions have a small mapping table for commonly used OIDs.  The
OIDs from RFC1213 (MIB-II) and RFC1316 (Frame Relay) are preloaded.

It is much easier to say "ifInOctets.4" instead of "1.3.6.1.2.1.2.2.1.10.4".
The snmpmapOID() function will let you add your own entries to the mapping
table.  It doesn't return anything.  Be sure to leave off any instance
number from the OID passed to snmpmapOID()!  The example above would be
    &snmpmapOID("ifInOctets", "1.3.6.1.2.1.2.2.1.10").
Don't use
    &snmpmapOID("ifInOctets.4", "1.3.6.1.2.1.2.2.1.10.4").
The trailing ".4" is interpreted as an instance number, and not the entire
OID.  The snmpmapOID function will ignore the attempt to add a mapping entry
that includes an instance number.  The call
    &snmpmapOID("ifInOctets.four", "1.3.6.1.2.1.2.2.1.10.4")
would be accepted, because the text ".four" is interpreted differently
than the number 4.

The snmpMIB_to_OID() function will open the passed-in MIB file name
and read it.  It will create text mappings for the appropriate OID
number.  It returns the number of text mappings added, so a zero or
negative return indicates an error.

The snmpLoad_OID_Cache() function will open the passed-in file name
and read the file.  It is expecting lines with a text string in
the first column and an OID number in the second column, like

    ifInOctets	1.3.6.1.2.1.2.2.1.10
    ifOutOctets	1.3.6.1.2.1.2.2.1.16

It will add the text to OID mappings in the file to the internal list by
calling the "snmpmapOID()" function.  This way the extra overhead of
parsing a MIB file can be avoided if you have a pre-parsed version of
the MIB handy.

The snmpQueue_MIB_File() function queues up file names for use by the
"snmpMIB_to_OID()" function.  If there are filenames passed into
"snmpQueue_MIB_File()", when an OID can't be found in the internal
table, the queued MIB files are loaded one after another until the
OID can be found (or the list is exhausted).  This delays the MIB
parsing until the OID value is actually needed.

A cache file with the looked up text-to-OID mappings is maintained.
It's name is "OID_cache.txt", and can be changed by setting the
variable $SNMP_util::CacheFile to the name of the file you desire.
This cache file is automatically loaded before the queued MIB files
are parsed.  If the OID is found in the cache file, the MIB file
doesn't have to be parsed.



The rest of the functions require a hostname/IP address as the first
argument.  The community string, port number, timeout, retries, and backoff
values are all optional.  If the community string isn't specified,
"public" is used.  If the port number isn't specified, 161 is used
for everything but snmptrap().  snmptrap() uses port 162 as its default.

The timeout, retries, and backoff values default to whatever SNMP_Session.pm
uses.  For SNMP_Session.pm version 0.63 they are 2 seconds, 5 retries, and a
1.0 backoff factor.  The backoff factor is used as a multiplier to increase
the timeout after every retry.  With a backoff factor of 1.0 the timeout
stays the same for every retry.

The snmpget function returns an array with the results of the 'get'
operation.  The value associated with each OID is returned as a
separate value in the array.

The snmpgetnext function returns an array with the results of the
'getnext' operation.  The OID number is added to the result as a
prefix with a colon separator, like '1.3.6.1.2.1.2.2.1.2.1:ethernet'

The snmpwalk function only accepts one OID number as an argument, and
returns an array with all the OID numbers and values.  The instance
part of the OID number is added as a prefix just like in the
snmpgetnext functions.  A walk might return an array like
'1:ethernet', '2:ethernet', '3:fddi'.

The snmpset function is passed OID, type, and value triplets.  It
returns an array with the result of the set.

Here is a simple example of using the functions:

#! /usr/local/bin/perl5
BEGIN {

###
# Finally, SNMPGet fully written in PERL5. 
# Thanks to Simon Leinen <simon@switch.ch>
# More on: http://www.switch.ch/misc/leinen/snmp/perl/
####

# There older perls tend to behave peculiar with
# large integers ... 
require 5.003;

use SNMP_util "0.56";
}

use strict;

$main::DEBUG=0;

sub main {
  
  my($oid, $host, $response, $cont);
  my($desc, @ret);

  $host = "127.0.0.1";
  $cont = "Your Name";

  # This snmpmapOID() isn't necessary, as it is already in
  # the internal map table.  It is just an example...
  &snmpmapOID("ifDescr", "1.3.6.1.2.1.2.2.1.2");

  print "Trying 'getnext' on $host\n";
  @ret = &snmpgetnext($host, "ifDescr");
  foreach $desc (@ret)
  {
    ($oid, $desc) = split(':', $desc, 2);
    print "$oid = $desc\n";
  }

  print "Trying 'walk' on $host\n";
  @ret = &snmpwalk($host, "ifDescr");
  foreach $desc (@ret)
  {
    ($oid, $desc) = split(':', $desc, 2);
    print "$oid = $desc\n";
  }

  print "Before set:\n";
  $oid = "sysContact";
  ($response) = &snmpget($host, $oid);
  if ($response)
  {
    print "GET $oid : $response\n";
  }
  else
  {
    warn "$host did not respond to SNMP query\n";
  }

  my $oldContact = $response;

  print "setting contact to $cont\n";
  ($response) = &snmpset("security\@$host", $oid, 'string', $cont);

  if ($response)
  {
    print "SET: $oid : $response\n";
  }
  else
  {
    die "$host did not respond to SNMP set\n";
  }

  print "After set:\n";
  ($response) = &snmpget($host, $oid);
  if ($response)
  {
    print "GET $oid : $response\n";
  }
  else
  {
    die "$host did not respond to SNMP query\n";
  }

  print "Setting contact back to $oldContact\n";
  ($response) = &snmpset("security\@$host", $oid, 'string', $oldContact);

  if ($response) {
    print "SET: $oid : $response\n";
  }
  else
  {
    die "$host did not respond to SNMP set\n";
  }

  print "After 2nd set:\n";
  ($response) = &snmpget($host, $oid);
  if ($response) {
    print "GET $oid : $response\n";
  }
  else
  {
    die "$host did not respond to SNMP query\n";
  }
}
main;
exit(0);
-----------------------------------------------------
Here is an example using the MIB parsing functions.
First create a file with a simple MIB:
cat > dummy.mib <<EOF
abc OBJECT IDENTIFIER ::=  { system 1  }
EOF

#! /usr/local/bin/perl5
BEGIN {

# The older perls tend to behave peculiar with
# large integers ... 
require 5.003;

use SNMP_util "0.71";
}

use strict;

sub main {
    my ($ret, $arg);

    # queue up reading the "dummy.mib" file
    &snmpQueue_MIB_File("dummy.mib");

    # Override the default cache file ("OID_cache.txt") with "cache_test.txt"
    $SNMP_util::CacheFile = "cache_test.txt";

    ($ret) = &snmpget("127.0.0.1", "abc.0");
    print "$ret\n";
}

main;
exit(0);
-----------------------------------------------------
The first time you run the above script, the "dummy.mib" file will be read
and parsed.  You should see the "cache_test.txt" file get created with
a single line in it, namely "abc 1.3.6.1.2.1.1.1". The second time you
run the script the "cache_test.txt" file will be loaded instead of the
"dummy.mib" file.
